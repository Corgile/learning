在C++17及之后 `std::atomic<int> n = 6;` 可以通过编译，主要是因为C++17引入了对复制消除的强制要求，
允许从基础类型直接初始化 `std::atomic` 对象， 即使 `std::atomic<int>` 的复制构造函数被删除。

在C++17之前， 这种初始化因为尝试调用被删除的复制构造函数而失败。
这个例子其实展示的是C++17改进了直接初始化和复制消除的规则，而不是传统意义上的RVO。
